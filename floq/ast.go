//  abstract syntax tree generated by yacc grammar
package main

import (
	"errors"
	"fmt"
)

type ast struct {

	yy_tok		int
	line_no		int
	order		int
	name		string

	//  children
	left		*ast
	right		*ast

	//  siblings
	next		*ast
	prev		*ast

	parent		*ast

	//  golang needs unions!

	tuple_ref	*tuple
	command_ref	*command
	uint64
	string
}

func (a *ast) yy_name() string {
	if a == nil {
		return "nil"
	}
	return yy_name(a.yy_tok)
}

func (a *ast) String() string {

	var what string

	if a == nil {
		return "nil AST"
	}

	switch a.yy_tok {
	case 0:
		a.corrupt("ast has yy_tok == 0")
	case ARG_LIST:
		what = fmt.Sprintf("ARG_LIST(argc=%d)", a.uint64)
	case STRING:
		if a.name == "" {
			what = fmt.Sprintf("STRING(%s)", a.string)
		} else {
			what = fmt.Sprintf("STRING#%s(%s)", a.name, a.string)
		}
	case NAME:
		what = fmt.Sprintf("NAME(%s)", a.string)
	case UINT64:
		what = fmt.Sprintf("UINT64(%d)", a.uint64)
	case yy_AND:
		what = "AND"
	case yy_OR:
		what = "OR"
	case yy_FALSE:
		what = "FALSE"
	case yy_TRUE:
		what = "TRUE"
	case STMT:
		what = fmt.Sprintf(
				"STMT(ord=#%d@lno=#%d)",
				a.uint64,
				a.line_no,
		)
	default:
		if a.name == "" {
			what = a.yy_name()
		} else {
			what = fmt.Sprintf("%s#%s", a.yy_name(), a.name)
		}
	}
	return what
}

func (a *ast) walk_print(indent int, parent *ast) {

	if a == nil {
		return
	}
	if a.parent != parent {
		if a.parent == nil {
			a.corrupt("unexpected nil parent")
		} else {
			a.corrupt("unexpected parent: %s", a.parent.yy_name())
		}
	}
	if indent == 0 {
		fmt.Println("")
	} else {
		if a.parent == nil {
			corrupt("parent ast is nil")
		}
		for i := 0;  i < indent;  i++ {
			fmt.Print("  ")
		}
	}
	fmt.Println(a.String())

	//  print kids

	a.left.walk_print(indent + 1, a)
	a.right.walk_print(indent + 1, a)

	//  print siblings

	if a.prev == nil {
		for as := a.next;  as != nil;  as = as.next {
			as.walk_print(indent, parent)
		}
	}
}

func (a *ast) print() {
	a.walk_print(0, nil)
}

func (a *ast) corrupt(format string, args...interface{}) {

	msg := fmt.Sprintf(format, args...)
	corrupt("%s: node \"%s\", near line %d", msg, a.yy_name(), a.line_no)
	//  NOTREACHED*/
}

//  is the node a binary operator(), left and right must exit
func (a *ast) is_binary() bool {
	switch a.yy_tok {
	case yy_OR, yy_AND, LT, LTE, EQ, NEQ, GTE, GT:
		return true
	}
	return false
}

//  is the node a unary operator(), left only exists
func (a *ast) is_unary() bool {
	switch a.yy_tok {
	case NOT, WHEN:
		return true
	}
	return false
}

func (a *ast) is_flowable() bool {
	switch a.yy_tok {
	case RUN:
		return true
	}
	return false
}

//  insure type of parent ast node is in expected yy token set...

func (a *ast) frisk_parent(expect ...int) error {
	if a == nil {
		return errors.New("frisk_parent: unexpected nil node")
	}

	if a.parent == nil {
		return errors.New("frisk_parent: parent is nil")
	}
	if !a.parent.in_tok_set(expect...) {
		return errors.New(fmt.Sprintf(
			"parent (%s) of %s not in yy token set: %s",
			a.parent.yy_name(),
			a.yy_name(),
			yy_names(expect...),
		))
	}
	return nil
}

func (a *ast) in_tok_set(expect ...int) bool {

	for _, tok := range expect {
		if tok == a.yy_tok {
			return true
		}
	}
	return false
}

func (a *ast) error(format string, args...interface{}) error {

	return errors.New(
		fmt.Sprintf("node %s: %s",
			a.yy_name(),
			fmt.Sprintf(format, args...),
	))
}

//  verify type of ast kids are in expected yy type set... and
//  point to proper relatives.

func (a *ast) frisk_kids(twig string, expect ...int) error {
	if a == nil {
		return errors.New(twig + " node is kill")
	}

	e := func(kid *ast, format string, args...interface{}) error {
		fmt := fmt.Sprintf("%s kid (%s)", twig, kid.yy_name())
		return a.error(fmt, args...)
	}

	var k_prev, k *ast
	if twig == "left" {
		k = a.left
	} else {
		k = a.right
	}
	if k == nil {
		return nil
	}
	for ;  k.next != nil;  k = k.next { 
		if k.parent == nil {
			return e(k, "has nil parent")
		}
		if k.parent != a {
			return e(k, "wrong parent (%s)", k.parent.yy_name()) 
		}
		if k_prev != nil && k.prev != k_prev {
			return e(k, "has wrong prev (%s)", k.prev.yy_name())
		}
		found := k.in_tok_set(expect...)
		if !found {
			return e(k, "not in tok set (%s)", yy_names(expect...))
		}
		k_prev = k
	}
	return nil
}

//
//  derive the type of the ast expression.
//
//  Note:
//	why not put the type of an expression in the ast while parsing
//
func (a *ast) yy_type() string {
	switch a.yy_tok {
	case yy_TRUE, yy_FALSE,
	     LT,  LTE,  EQ,  NEQ,  GTE,  GT:
		return "bool"
	case STRING, CONCAT:
		return "string"
	case UINT64:
		return "uint64"
	}
	return "unknown"
}

//  Frisk an ast tree for wiring mistakes, panic on error

func (a *ast) frisk() {

	//  can we invoke a.frisk() on nil *ast?

	if a == nil {
		return
	}

	_corrupt := func(format string, args...interface{}) {
		a.corrupt("frisk: " + format, args...)
	}

	if a.left != nil {
		a.left.frisk()
	}
	if a.right != nil {
		a.right.frisk()
	}

	if a.is_binary() {
		if a.left == nil {
			_corrupt("left child is nil")
		}
		if a.right == nil {
			_corrupt("right child is nil")
		}
	} else if a.is_unary() {
		if a.right != nil {
			_corrupt("right exists for unary op")
		}
	}
	if a.parent == nil {
		_corrupt("parent is nil")
	}

	ckparent := func(expect ...int) {

		err := a.frisk_parent(expect...)
		if err != nil {
			_corrupt("ckparent: %s", err)
		}
	}

	ckrelop := func() {

		if a.left == nil {
			_corrupt("ckrelop: left is nil")
		}

		tok := a.left.yy_tok
		switch tok {
		case STRING, UINT64, yy_TRUE, yy_FALSE:
		default:
			_corrupt("bad relop type: %s", yy_name(tok))
		}
	}

	switch a.yy_tok {
	case NAME:
	case yy_TRUE:
	case yy_FALSE:
	case STRING:
	case UINT64:
	case STMT:
		ckparent(STMT_LIST)
	case STMT_LIST:
		_corrupt("unexpected STMT_LIST")
	case CONCAT:
	case ARG_LIST:
		if a.right != nil {
			_corrupt("right node (%s) not nil", a.right.yy_name())
		}

		//  verify all args are expressions with proper parent
		for arg := a.left;  arg != nil;  arg = arg.next {
			if arg.parent != a {
				fmt := "parent (%s) of arg (%s) not this arg"
				_corrupt(
					fmt,
					arg.parent.yy_name(),
					arg.yy_name(),
				)
			}
			if arg.is_expression() == false {
				_corrupt(
					"arg node (%s) not expr",
					arg.yy_name(),
				)
			}
		}
	case RUN:
		/*
		 *  Parse tree
	         *	RUN
		 *		ARG_LIST(argc=0)
		 *		WHEN
		 *			(bool expression)?
		 */
		al := a.left
		if al == nil {
			_corrupt("left node is nil")
		}
		if al.yy_tok != ARG_LIST {
			_corrupt("left node (%s) not ARG_LIST", al.yy_name())
		}

		//  WHEN clause must have qualification
		w := a.right
		if w != nil {
			if w.yy_tok != WHEN {
				_corrupt("right node (%s) not WHEN", w.yy_name())
			}
			wl := w.left
			if wl == nil {
				_corrupt("WHEN.left is nil")
			}
			if wl.is_bool() == false {
				_corrupt(
					"WHEN.left (%s) not bool",
					wl.yy_name(),
				)
			}
		}
	case LT, LTE, EQ, NEQ, GTE, GT:
		ckrelop()
	case yy_OR:
	case yy_AND:
	case NOT:
	case WHEN:
		if a.parent.is_flowable() == false {
			nm := a.parent.yy_name()
			_corrupt("parent of WHEN (%s) not flowable", nm)
		}
		if a.left.is_bool() == false {
			_corrupt("qualification (%s) not bool",a.left.yy_name())
		}
	default:
		_corrupt("unknown ast node")
	}
}

//  Note: outght too be "is_value()"
func (a *ast) is_expression() bool {
	return a.is_bool() || a.is_string() || a.is_uint64()
}

//  Note:  change to multiple tokens ... instead of is_flowable()
func (a *ast) count(tokens ...int) int {
	
	if a == nil {
		return 0
	}
	count := 0
	if a.in_tok_set(tokens...) {
		count++
	}
	count += a.left.count(tokens...)
	count += a.right.count(tokens...)

	if a.prev == nil {
		for kid := a.next;  kid != nil;  kid = kid.next {
			count += kid.count(tokens...)
		}
	}
	return count
}

func (parent *ast) push_left(kid *ast) {

	var k *ast

	kid.parent = parent
	kid.order++
	if parent.left == nil {
		parent.left = kid
		return
	}
	for k = parent.left;  k.next != nil;  k = k.next {} 
	k.next = kid
	kid.prev = k
}
