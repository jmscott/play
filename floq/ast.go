//  abstract syntax tree generated by yacc grammar
package main

import (
	"errors"
	"fmt"
)

type ast struct {

	yy_tok		int
	line_no		int

	//  children
	left		*ast
	right		*ast

	//  siblings
	previous	*ast
	next		*ast

	parent		*ast

	//  golang needs unions!

	tracer_ref	*tracer
	scanner_ref	*scanner
	command_ref	*command
	uint64
	string
	array_ref	[]string
}

func (a *ast) name() string {
	if a == nil {
		return "nil"
	}
	return yy_name(a.yy_tok)
}

func (a *ast) String() string {

	var what string

	if a == nil {
		return "nil AST"
	}

	switch a.yy_tok {
	case 0:
		a.corrupt("ast has yy_tok == 0")
	case ARG_LIST:
		what = fmt.Sprintf("ARG_LIST(argc=%d)", a.uint64)
	case SCANNER_REF:
		what = fmt.Sprintf("SCANNER_REF(%s)", a.scanner_ref.name)
	case COMMAND_REF:
		what = fmt.Sprintf("COMMAND_REF(%s)", a.command_ref.name)
	case TRACER_REF:
		what = fmt.Sprintf("TRACER_REF(%s)", a.tracer_ref.name)
	case STRING:
		what = fmt.Sprintf("STRING(%s)", a.string)
	case NAME:
		what = fmt.Sprintf("NAME(%s)", a.string)
	case UINT64:
		what = fmt.Sprintf("UINT64(%d)", a.uint64)
	case ATT_ARRAY:
		ar := a.array_ref
		what = fmt.Sprintf("ATT_ARRAY(len=%d,cap=%d)", len(ar), cap(ar))
	case yy_AND:
		what = "AND"
	case yy_OR:
		what = "OR"
	case yy_FALSE:
		what = "FALSE"
	case yy_TRUE:
		what = "TRUE"
	case STMT_LIST:
		what = fmt.Sprintf("STMT_LIST(cnt=#%d)", a.uint64)
	case STMT:
		what = fmt.Sprintf(
				"STMT(ord=#%d@lno=#%d)",
				a.uint64,
				a.line_no,
		)
	default:
		what = a.name()
	}
	return what
}

func (a *ast) walk_print(indent int, parent *ast) {

	if a == nil {
		return
	}
	if a.parent != parent {
		if a.parent == nil {
			a.corrupt("unexpected nil parent")
		} else {
			a.corrupt("unexpected parent: %s", a.parent.name())
		}
	}
	if indent == 0 {
		fmt.Println("")
	} else {
		if a.parent == nil {
			corrupt("parent ast is nil")
		}
		for i := 0;  i < indent;  i++ {
			fmt.Print("  ")
		}
	}
	fmt.Println(a.String())

	//  print kids

	a.left.walk_print(indent + 1, a)
	a.right.walk_print(indent + 1, a)

	//  print siblings

	if a.previous == nil {
		for as := a.next;  as != nil;  as = as.next {
			as.walk_print(indent, parent)
		}
	}
}

func (a *ast) print() {
	a.walk_print(0, nil)
}

func (a *ast) frisk_att(what string, need...ast) error {

	if a.yy_tok != ATT_TUPLE {
		corrupt("start node not ATT_TUPLE")
	}

	const fmt_dup = "duplicate attribute"
	const fmt_need = "need attribute"
	const fmt_no = "unknown attribute"
	const fmt_type = "wrong type"
	const fmt_nostr = "STRING empty"

	err := func(name string, lno int, msg string) error {

		name = "node \"" + name + "\""
		near := ", near line " + fmt.Sprintf("%d", lno)
		return errors.New(msg + ": " + what + ": " + name + near)
	}

	//  map list of need ast to name for quick check

	name2need := make(map[string]*ast)
	for _, an := range need {
		name2need[an.string] = &an
	}

	seen := make(map[string]*ast)

	//  scan each ATT nodes of ATT_TUPLE

	for an := a.left;  an != nil;  an = an.next {
		if an.yy_tok != ATT {
			an.corrupt("left node not ATT")
		}
		name := an.left.string
		
		//  more than one att exists
		if seen[name] != nil {
			return err(name, seen[name].line_no, fmt_dup)
		}
		ar := an.right
		if ar == nil {
			an.corrupt("ATT has nil right")
		}

		//  is the node known?
		ann := name2need[name]
		if ann == nil {
			return err(name, an.line_no, fmt_no)	//  unkn
		}

		/*
		 * do the types match?
		 *
		 *  Note:
		 *	error message "wrong type:" is opaque.  ought to include
		 *	expected type
		 */
		if ar.yy_tok != ann.yy_tok {
			return err(name, ar.line_no, fmt_type)
		}

		//  no empty strings
		if ar.yy_tok == STRING && ar.string == "" {
			return err(name, ar.line_no, fmt_nostr)
		}
		seen[name] = ar
	}

	//  scan for required nodes in "need" twig
	for nm, an := range name2need {
		
		if an.uint64 > 0 && seen[nm] == nil {
			return err(nm, an.line_no, fmt_need)
		}
	}

	return nil
}

func (a *ast) corrupt(format string, args...interface{}) {

	msg := fmt.Sprintf(format, args...)
	corrupt("%s: node \"%s\", near line %d", msg, a.name(), a.line_no)
	//  NOTREACHED*/
}

func (at *ast) find_ATT(name string) (*ast) {

	if at.yy_tok != ATT_TUPLE {
		at.corrupt("node not ATT_TUPLE")
	}
	for a := at.left;  a != nil;  a = a.next {
		if a.parent != at {
			a.corrupt("parent not ATT_TUPLE")
		}
		if a.yy_tok != ATT {
			a.corrupt("child not ATT")
		}
		if a.left == nil {
			a.corrupt("left is nil")
		}
		if a.left.string == name {
			return a
		}
	}
	return nil
}

//  is the node a binary operator(), left and right must exit
func (a *ast) is_binary() bool {
	switch a.yy_tok {
	case yy_OR, yy_AND, LT, LTE, EQ, NEQ, GTE, GT:
		return true
	}
	return false
}

//  is the node a unary operator(), left only exists
func (a *ast) is_unary() bool {
	switch a.yy_tok {
	case NOT, WHEN:
		return true
	}
	return false
}

func (a *ast) is_flowable() bool {
	switch a.yy_tok {
	case RUN:
		return true
	}
	return false
}

//  insure type of parent ast node is in expected yy token set...

func (a *ast) frisk_parent(expect ...int) error {
	if a == nil {
		return errors.New("frisk_parent: unexpected nil node")
	}

	if a.parent == nil {
		return errors.New("frisk_parent: parent is nil")
	}
	if !a.parent.in_tok_set(expect...) {
		return errors.New("parent not in exected yy token set")
	}
	return nil
}

func (a *ast) in_tok_set(expect ...int) bool {

	for _, tok := range expect {
		if tok == a.yy_tok {
			return true
		}
	}
	return false
}

//  insure type of ast kids are in expected yy type set... and
//  point to proper nodes.

func (a *ast) frisk_kids(expect ...int) error {
	if a == nil {
		return errors.New("node is kill")
	}
	var kid_prev *ast
	for kid := a.left;  a.next != nil;  a = a.next { 
		if kid.parent != a {
			return errors.New("kid has wrong parent")
		}
		if kid_prev != nil && kid.previous != kid_prev {
			return errors.New("kid has wrong prev")
		}
		found := kid.in_tok_set(expect...)
		if !found {
			return errors.New("kid not expected yy_tok")
		}
		kid_prev = kid
	}
	return nil
}

//
//  derive the type of the ast expression.
//
//  Note:
//	why not put the type of an expression in the ast while parsing
//
func (a *ast) yy_type() string {
	switch a.yy_tok {
	case yy_TRUE, yy_FALSE,
	     LT,  LTE,  EQ,  NEQ,  GTE,  GT:
		return "bool"
	case STRING, CONCAT:
		return "string"
	case UINT64:
		return "uint64"
	}
	return "unknown"
}

//  Frisk an ast for wiring mistaskes.

func (a *ast) frisk() {

	//  can we invoke a.frisk() on nil *ast?

	if a == nil {
		return
	}

	_corrupt := func(format string, args...interface{}) {
		a.corrupt("frisk: " + format, args...)
	}

	if a.left != nil {
		a.left.frisk()
	}
	if a.right != nil {
		a.right.frisk()
	}

	if a.is_binary() {
		if a.left == nil {
			_corrupt("left child is nil")
		}
		if a.right == nil {
			_corrupt("right child is nil")
		}
	} else if a.is_unary() {
		if a.right != nil {
			_corrupt("right exists for unary op")
		}
	}
	if a.parent == nil {
		_corrupt("parent is nil")
	}

	ckparent := func(expect ...int) {

		for _, tok := range expect {
			if a.parent.yy_tok == tok {
				return
			}
		}
		_corrupt("unexpected parent node: %s", a.parent.name())
	}

	ckleft := func(expect ...int) {

		if a.left == nil {
			_corrupt("left is nil")
		}
		for _, tok := range expect {
			if a.left.yy_tok == tok {
				return
			}
		}
		_corrupt("unexpected left node: %s", a.left.name())
	}

	ckrelop := func() {

		tok := a.left.yy_tok

		switch tok {
		case STRING, UINT64, yy_TRUE, yy_FALSE:
		default:
			_corrupt("bad relop type: %s", yy_name(tok))
		}
	}

	//  Note:  consider moving parts of this code to ast.frisk()
	switch a.yy_tok {
	case NAME:
	case ATT:
		ckparent(ATT_TUPLE)
	case ATT_TUPLE:
		ckparent(COMMAND_REF, SCANNER_REF, TRACER_REF)
	case yy_TRUE:
	case yy_FALSE:
	case STRING:
	case UINT64:
	case SCANNER_REF:
		ckleft(ATT_TUPLE)
	case CREATE:
		ckparent(STMT)
	case STMT:
		ckparent(STMT_LIST)
	case STMT_LIST:
		_corrupt("unexpected STMT_LIST")
	case TRACER_REF, COMMAND_REF:
		ckleft(ATT_TUPLE)
	case ARG_LIST:
	case RUN:
	case LT, LTE, EQ, NEQ, GTE, GT:
		ckrelop()
	case yy_OR:
	case yy_AND:
	case NOT:
	case WHEN:
		if a.parent.is_flowable() == false {
			nm := a.parent.name()
			_corrupt("parent of WHEN (%s) not flowable", nm)
		}
		if a.left.is_bool() == false {
			_corrupt("qualification (%s) not bool", a.left.name())
		}
	default:
		_corrupt("unknown ast node")
	}
}
