//  abstract syntax tree generated by yacc grammar
package main

import (
	"errors"
	"fmt"
	"strings"
)

type ast struct {

	yy_tok		int
	line_no		int

	//  children
	left		*ast
	right		*ast

	//  siblings
	previous	*ast
	next		*ast

	parent		*ast

	//  golang needs unions!

	tracer_ref	*tracer
	scanner_ref	*scanner
	command_ref	*command
	uint64
	string
	array_ref	[]string
}

func (a *ast) name() string {
	if a == nil {
		return "nil"
	}
	return yy_name(a.yy_tok)
}

func (a *ast) String() string {

	var what string

	switch a.yy_tok {
	case 0:
		impossible("ast has yy_tok == 0")
	case ARG_LIST:
		what = fmt.Sprintf("ARG_LIST(argc=%d)", a.uint64)
	case SCANNER_REF:
		what = fmt.Sprintf("SCANNER_REF(%s)", a.scanner_ref.name)
	case COMMAND_REF:
		what = fmt.Sprintf("COMMAND_REF(%s)", a.command_ref.name)
	case TRACER_REF:
		what = fmt.Sprintf("TRACER_REF(%s)", a.tracer_ref.name)
	case STRING:
		what = fmt.Sprintf("STRING(%s)", a.string)
	case NAME:
		what = fmt.Sprintf("NAME(%s)", a.string)
	case UINT64:
		what = fmt.Sprintf("UINT64(%d)", a.uint64)
	case ATT_ARRAY:
		ar := a.array_ref
		what = fmt.Sprintf("ATT_ARRAY(len=%d,cap=%d)", len(ar), cap(ar))
	case yy_AND:
		what = "AND"
	case yy_OR:
		what = "OR"
	case yy_FALSE:
		what = "FALSE"
	case yy_TRUE:
		what = "TRUE"
	case STMT_LIST:
		what = fmt.Sprintf("STMT_LIST(cnt=#%d)", a.uint64)
	case STMT:
		what = fmt.Sprintf("STMT(#%d @ lno=#%d)", a.uint64, a.line_no)
	default:
		what = a.name()
	}
	return what
}

func (a *ast) walk_print(indent int) {

	if a == nil {
		return
	}
	if indent == 0 {
		fmt.Println("")
	} else {
		if a.parent == nil {
			impossible("parent ast is nil")
		}
		for i := 0;  i < indent;  i++ {
			fmt.Print("  ")
		}
	}
	fmt.Println(a.String())

	//  print kids

	a.left.walk_print(indent + 1)
	a.right.walk_print(indent + 1)

	//  print siblings

	if a.previous == nil {
		for as := a.next;  as != nil;  as = as.next {
			as.walk_print(indent)
		}
	}
}

func (a *ast) print() {
	a.walk_print(0)
}

func (a *ast) frisk_att2(what string, need...ast) error {

	if a.yy_tok != ATT_TUPLE {
		impossible("start node not ATT_TUPLE")
	}

	const fmt_dup = "duplicate attribute"
	const fmt_need = "need attribute"
	const fmt_no = "unknown attribute"
	const fmt_type = "wrong type"
	const fmt_nostr = "STRING empty"

	err := func(name string, lno int, msg string) error {

		name = "\"" + name + "\""
		near := ", near line " + fmt.Sprintf("%d", lno)
		return errors.New(msg + ": " + what + ": " + name + near)
	}

	//  map list of need ast to name for quick check

	name2need := make(map[string]*ast)
	for _, an := range need {
		name2need[an.string] = &an
	}

	seen := make(map[string]*ast)

	//  scan each ATT nodes of ATT_TUPLE

	for an := a.left;  an != nil;  an = an.next {
		if an.yy_tok != ATT {
			an.impossible("left node not ATT")
		}
		name := an.left.string
		
		//  more than one att exists
		if seen[name] != nil {
			return err(name, seen[name].line_no, fmt_dup)
		}
		ar := an.right
		if ar == nil {
			an.impossible("ATT has nil right")
		}

		//  is the node known?
		ann := name2need[name]
		if ann == nil {
			return err(name, an.line_no, fmt_no)	//  unkn
		}

		/*
		 * do the types match?
		 *
		 *  Note:
		 *	error message "wrong type:" is opaque.  ought to include
		 *	expected type
		 */
		if ar.yy_tok != ann.yy_tok {
			return err(name, ar.line_no, fmt_type)
		}

		//  no empty strings
		if ar.yy_tok == STRING && ar.string == "" {
			return err(name, ar.line_no, fmt_nostr)
		}
		seen[name] = ar
	}

	//  scan for required nodes in "need" twig
	for nm, an := range name2need {
		
		if an.uint64 > 0 && seen[nm] == nil {
			return err(nm, an.line_no, fmt_need)
		}
	}

	return nil
}

//  frisk ast of attributes for duplicates and missing required and
//  correct types: STRING, UINT64, ARRAY_REF
//
//  Note:
//	Currently [ arrays ] can contain mixed types.
//

func (a *ast) frisk_att(what string, need...interface{}) error {

	if a.yy_tok != ATT_TUPLE {
		impossible("start node not ATT_TUPLE")
	}
	const fmt_dup = "duplicate attribute"
	const fmt_need = "need attribute"

	err := func(name string, lno int, msg string) error {

		name = "\"" + name + "\""
		near := ", near line " + fmt.Sprintf("%d", lno)
		return errors.New(msg + ": " + what + ": " + name + near)
	}

	//  frisk for duplicate attributes and record right hand node of ATT

	seen := make(map[string]*ast)

	for an := a.left;  an != nil;  an = an.next {
		if an.yy_tok != ATT {
			an.impossible("left node not ATT")
		}
		name := an.left.string
		if seen[name] != nil {
			return err(name, seen[name].line_no, fmt_dup)
		}
		if an.right == nil {
			an.impossible("ATT has nil right")
		}
		seen[name] = an.right
	}

	//  insure required atts exist and match types

	for _, val := range need {
		name_tok := strings.Split(val.(string), ":")
		if len(name_tok) != 2 {
			a.impossible("corrupt name:yy_tok: '%s'", val)
		}
		nm, tok_nm := name_tok[0], name_tok[1]
		if len(nm) == 0 {
			a.impossible("name:tok: name is 0 length")
		}
		if len(tok_nm) == 1 {
			a.impossible("name:tok: tok name is empty")
		}
		tok := yy_name2tok(tok_nm)
		if tok <= __MIN_YYTOK  {
			a.impossible("name:tok: yy_tok is unknown: %s", tok_nm)
		}

		ar := seen[nm]
		if ar == nil {
			return err(nm, a.line_no, fmt_need)
		}
		if tok != ar.yy_tok {
			ar.impossible("ATT: right yy_tok not %s", tok_nm)
		}
	}
	return nil
}

func (a *ast) impossible(format string, args...interface{}) {

	msg := fmt.Sprintf(format, args...)
	impossible("%s: %s, near line %d", msg, a.name(), a.line_no)
	//  NOTREACHED*/
}

func (at *ast) find_ATT(name string) (*ast) {

	if at.yy_tok != ATT_TUPLE {
		at.impossible("node not ATT_TUPLE")
	}
	for a := at.left;  a != nil;  a = a.next {
		if a.parent != at {
			a.impossible("parent not ATT_TUPLE")
		}
		if a.yy_tok != ATT {
			a.impossible("child not ATT")
		}
		if a.left == nil {
			a.impossible("left is nil")
		}
		if a.left.string == name {
			return a
		}
	}
	return nil
}
