//  abstract syntax tree generated by yacc grammar
package main

import (
	"errors"
	"fmt"
)

type ast struct {

	yy_tok		int
	line_no		uint32
	order		uint32
	count		uint32
	name		string

	//  children
	left		*ast
	right		*ast

	//  siblings
	next		*ast
	prev		*ast

	parent		*ast

	proj_ref	*projection
	tuple_ref	*tuple
	command_ref	*command
	att_ref		*attribute

	uint64
	string
	bool
	*set
}

func (a *ast) yy_name() string {
	if a == nil {
		return "nil"
	}
	return yy_name(a.yy_tok)
}

func (a *ast) String() string {

	var what string

	if a == nil {
		return "(ast*)(nil)"
	}

	colon := ":"
	if a.left == nil && a.right != nil {
		colon = "\\"
	} else if a.left != nil && a.right == nil {
		colon = "/"
	}

	switch a.yy_tok {
	case 0:
		a.corrupt("ast has yy_tok == 0")
	case ARGV:
		what = fmt.Sprintf("ARGV%s (cnt=%d)", colon, a.count)
	case ARRAY:
		if a.name == "" {
			what = fmt.Sprintf(
				"ARRAY%s (cnt=%d)",
				colon,
				a.count,
			)
		} else {
			what = fmt.Sprintf(
				"ARRAY%s%s (cnt=%d)",
				colon,
				a.name,
				a.count,
			)
		}

	case DEFINE:
		what = fmt.Sprintf(
			"DEFINE%s (ord=%d, lno=%d)",
			colon,
			a.order,
			a.line_no,
		)
	case RUN:
		what = fmt.Sprintf(
				"RUN%s (ord=%d,lno=%d) ",
				colon,
				a.order,
				a.line_no,
			)
		what += a.command_ref.string(2)
	case STMT_LIST:
		what = fmt.Sprintf("STMT_LIST%s(cnt=%d)", colon, a.count)
	case yy_SET:
		crc64 := " set=nil"
		if a.set != nil {
			crc64 = fmt.Sprintf(" crc=%d", a.set.crc64())
		}
		if a.name == "" {
			what = fmt.Sprintf(
					"SET%s@%p (cnt=%d%s)",
						colon,
						a.set,
						a.count,
						crc64,
					)
		} else {
			what = fmt.Sprintf(
					"SET%s@%p %s (cnt=%d%s)",
					colon,
					a.set,
					a.name,
					a.count,
					crc64,
			)
		}
	case STRING:
		if a.name == "" {
			what = fmt.Sprintf(
					"STRING \"%s\"",
					a.string,
			)
		} else {
			what = fmt.Sprintf(
					"STRING:%s \"%s\"",
					a.name,
					a.string,
			)
		}
	case UINT64:
		if a.name == "" {
			what = fmt.Sprintf("UINT64 (%d)", a.uint64)
		} else {
			what = fmt.Sprintf("UINT64:%s (%d)", a.name, a.uint64)
		}
	case yy_AND:
		what = "AND"
	case yy_OR:
		what = "OR"
	case yy_FALSE:
		what = "FALSE"
	case yy_TRUE:
		what = "TRUE"
	case PROJECT_OSX_TUPLE_TSV:
		what = a.proj_ref.String()
	default:
		what = fmt.Sprintf("%s%s%s", a.yy_name(), colon, a.name)
	}
	return what
}

//  convert an abstract syntax tree to a set

func (aset *ast) parse_set() (*set, error) {

	_e := func(format string, args...interface{}) (*set, error) {
		return nil, fmt.Errorf("frisk_set: " + format, args...)
	}

	if aset.yy_tok != yy_SET {
		return _e("root not a set: %s", yy_name(aset.yy_tok))
	}

	//  find duplicate elements starting at left branch

	set := new_set()
	for ele := aset.left;  ele != nil;  ele = ele.next {
		switch ele.yy_tok {
		case UINT64:
			ui := ele.uint64
			if err := set.add_uint64(ui);  err != nil {
				return _e("add_uint64(%d) failed: %s", ui, err)
			}
		case yy_TRUE, yy_FALSE:
			b := ele.bool
			if err := set.add_bool(b);  err != nil {
				return _e("add_bool(%t) failed: %s", b, err)
			}
		case STRING:
			s := ele.string
			if err := set.add_string(s);  err != nil {

				//  trim string to 8 cha for error
				max := 8
				elipse := ""
				if len(s) > max {
					elipse = "..."
					s = s[:max]
				}
				return _e(
					"add_string(%s%s) failed: %s",
					s, elipse,
					err,
				)
			}
		case yy_SET:
			if _, err := ele.parse_set();  err != nil {
				return nil, err
			}
		default:
			aset.corrupt("impossible set element: %s", ele)
		}
	}
	 
	return set, nil
}

func (a *ast) walk_print(indent int, parent *ast) {

	if a == nil {
		return
	}
	if parent != nil && a.parent != parent {
		if a.parent == nil {
			a.corrupt("unexpected nil ast parent")
		}
		a.corrupt(
			"call parent(%s) not ast parent: %s",
			parent.yy_name(),
			a.parent.yy_name(),
		)
	}
	if indent == 0 {
		fmt.Println("")
	} else {
		if a.parent == nil {
			a.corrupt("indent > 0: ast parent is nil")
		}
		for i := 0;  i < indent;  i++ {
			fmt.Print("  ")
		}
	}

	fmt.Println(a.String())

	//  print kids

	a.left.walk_print(indent + 1, a)
	a.right.walk_print(indent + 1, a)

	//  print siblings

	if a.prev == nil {
		for as := a.next;  as != nil;  as = as.next {
			as.walk_print(indent, parent)
		}
	}
}

func (a *ast) print() {
	a.walk_print(0, nil)
}

func (a *ast) corrupt(format string, args...interface{}) {

	msg := fmt.Sprintf(format, args...)
	corrupt("%s: node \"%s\", near line %d", msg, a.yy_name(), a.line_no)
	//  NOTREACHED*/
}

//  is the node a binary operator(), left and right must exit
func (a *ast) is_binary() bool {
	switch a.yy_tok {
	case yy_OR, yy_AND, LT, LTE, EQ, NEQ, GTE, GT:
		return true
	}
	return false
}

//  is the node a unary operator(), left only exists
func (a *ast) is_unary() bool {
	switch a.yy_tok {
	case NOT, WHEN:
		return true
	}
	return false
}

func (a *ast) in_tok_set(expect ...int) bool {

	for _, tok := range expect {
		if tok == a.yy_tok {
			return true
		}
	}
	return false
}

func (a *ast) error(format string, args...interface{}) error {

	var lno string

	if a.line_no > 0 {
		lno = fmt.Sprintf(" @%d", a.line_no)
	}

	format = fmt.Sprintf("node %s%s: %s", a.yy_name(), lno, format)
	return fmt.Errorf(format, args...)
}

//  verify type of ast kids are in expected yy type set... and
//  point to proper relatives.

func (a *ast) frisk_kids(twig string, expect ...int) error {
	if a == nil {
		return errors.New(twig + " node is nil")
	}

	e := func(kid *ast, format string, args...interface{}) error {
		fmt := fmt.Sprintf("%s kid (%s)", twig, kid.yy_name())
		return a.error(fmt, args...)
	}

	var k_prev, k *ast
	if twig == "left" {
		k = a.left
	} else {
		k = a.right
	}
	if k == nil {
		return nil
	}
	for ;  k.next != nil;  k = k.next { 
		if k.parent == nil {
			return e(k, "has nil parent")
		}
		if k.parent != a {
			return e(k, "wrong parent (%s)", k.parent.yy_name()) 
		}
		if k_prev != nil && k.prev != k_prev {
			return e(k, "has wrong prev (%s)", k.prev.yy_name())
		}
		found := k.in_tok_set(expect...)
		if !found {
			return e(k, "not in tok set (%s)", yy_names(expect...))
		}
		k_prev = k
	}
	return nil
}

//
//  derive the type of the ast expression.
//
//  Note:
//	why not put the type of an expression in the ast while parsing
//
func (a *ast) yy_type() string {
	switch a.yy_tok {
	case yy_TRUE, yy_FALSE,
	     LT,  LTE,  EQ,  NEQ,  GTE,  GT:
		return "bool"
	case STRING, CONCAT:
		return "string"
	case UINT64:
		return "uint64"
	}
	return "unknown"
}

func (a *ast) is_expression() bool {
	return a.is_bool() || a.is_string() || a.is_uint64()
}

//  Note:  change to multiple tokens ... instead of is_flowable()
func (a *ast) yy_count(tokens ...int) int {
	
	if a == nil {
		return 0
	}
	count := 0
	if a.in_tok_set(tokens...) {
		count++
	}
	count += a.left.yy_count(tokens...)
	count += a.right.yy_count(tokens...)

	if a.prev == nil {
		for kid := a.next;  kid != nil;  kid = kid.next {
			count += kid.yy_count(tokens...)
		}
	}
	return count
}

func (parent *ast) push_left(kid *ast) {

	parent.push_lr(&parent.left, kid)
}

func (parent *ast) push_right(kid *ast) {

	parent.push_lr(&parent.right, kid)
}

func (parent *ast) push_lr(lr **ast, kid *ast) {

	var k *ast

	kid.parent = parent
	if *lr == nil {
		*lr = kid
		kid.order = 1
		parent.count = 1
		return
	}
	for k = *lr;  k.next != nil;  k = k.next {}
	k.next = kid
	kid.order = k.order + 1
	parent.count++
	kid.prev = k
}

func (set *ast) string_element(name string) string { 
	if set.yy_tok != yy_SET {
		set.corrupt("ast: expected SET, got %s", set.yy_name())
	}
	var kid *ast
	for kid = set.left;  kid != nil;  kid = kid.next {
		if kid.name != name {
			continue
		}
		if kid.yy_tok == STRING {
			return kid.string
		}
	}
	return ""
}

func (set *ast) set_element(name string) *ast { 
	if set.yy_tok != yy_SET {
		set.corrupt("expected SET, got %s", set.yy_name())
	}
	var kid *ast
	for kid = set.left;  kid != nil;  kid = kid.next {
		if kid.name == name && kid.yy_tok == yy_SET {
			return kid
		}
	}
	return nil
}

//  get a named array element from a set
func (set *ast) array_element(name string) (kid *ast) {
	if set.yy_tok != yy_SET {
		set.corrupt("expected SET, got %s", set.yy_name())
	}

	for kid = set.left;  kid != nil;  kid = kid.next {
		if kid.name == name && kid.yy_tok == ARRAY {
			return kid
		}
	}
	return nil
}

//  get a named []string from ARRAY element in a SET

func (set *ast) array_string_element(name string) []string { 

	if set.yy_tok != yy_SET {
		set.corrupt("expected SET, got %s", set.yy_name())
	}
	var kid *ast
	for kid = set.left;  kid != nil;  kid = kid.next {
		if kid.name == name && kid.yy_tok == ARRAY {
			break
		}
	}
	if kid == nil {
		return nil
	}
	ar := make([]string, kid.count)
	var cnt int
	for kid = kid.left;  kid != nil;  kid = kid.next {
		if kid.yy_tok == STRING {
			ar[cnt] = kid.string
			cnt++
		}
	}
	return ar[:cnt]
}

func (a *ast) yy_ancestor(yy_tok int) *ast {

	if a == nil {
		return nil
	}
	if a.yy_tok == yy_tok {
		return a
	}
	if a.parent == nil {
		return nil
	}
	return a.parent.yy_ancestor(yy_tok)
}
