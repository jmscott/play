//  abstract syntax tree generated by yacc grammar
package main

import (
	"errors"
	"fmt"
)

type ast struct {

	yy_tok		int
	line_no		uint32
	order		uint32
	count		uint32
	name		string
	ref_count	uint16

	//  children
	left		*ast
	right		*ast

	//  siblings
	next		*ast
	prev		*ast

	parent		*ast

	tuple_ref	*tuple
	command_ref	*command
	sysatt_ref	*sysatt
	uint64
	string
}

func (a *ast) yy_name() string {
	if a == nil {
		return "nil"
	}
	return yy_name(a.yy_tok)
}

func (a *ast) String() string {

	var what string

	if a == nil {
		return "(ast*)(nil)"
	}

	colon := ":"
	if a.left == nil && a.right != nil {
		colon = "\\"
	} else if a.left != nil && a.right == nil {
		colon = "/"
	}

	switch a.yy_tok {
	case 0:
		a.corrupt("ast has yy_tok == 0")
	case ARGV:
		what = fmt.Sprintf("ARGV%s (cnt=%d)", colon, a.count)
	case ARRAY:
		if a.name == "" {
			what = fmt.Sprintf(
				"ARRAY%s (cnt=%d)",
				colon,
				a.count,
			)
		} else {
			what = fmt.Sprintf(
				"ARRAY%s%s (cnt=%d)",
				colon,
				a.name,
				a.count,
			)
		}

	case DEFINE:
		what = fmt.Sprintf(
			"DEFINE%s (ord=%d, lno=%d)",
			colon,
			a.order,
			a.line_no,
		)
	case RUN:
		cmd := a.command_ref
		if cmd == nil {
			what = fmt.Sprintf(
					"RUN%s (ord=%d,lno=%d,rcnt=%d)",
					colon,
					a.order,
					a.line_no,
					a.ref_count,
			)
		} else {
			format := "RUN%s%s " +
				"(ord=%d,lno=%d," +
				"rcnt=%d,cmdac=%d)"
			what = fmt.Sprintf(
					format,
					colon,
					cmd.name,
					a.order,
					a.line_no,
					a.ref_count,
					len(cmd.args),
				)
		}
	case STMT_LIST:
		what = fmt.Sprintf("STMT_LIST%s(cnt=%d)", colon, a.count)
	case yy_SET:
		if a.name == "" {
			what = fmt.Sprintf("SET%s (cnt=%d)", colon, a.count)
		} else {
			what = fmt.Sprintf(
					"SET%s%s (cnt=%d)",
					colon,
					a.name,
					a.count,
			)
		}
	case STRING:
		if a.name == "" {
			what = fmt.Sprintf(
					"STRING (ord=%d) %s",
					a.order,
					a.string,
			)
		} else {
			what = fmt.Sprintf(
					"STRING:%s (ord=%d) %s",
					a.name,
					a.order,
					a.string,
			)
		}
	case UINT64:
		if a.name == "" {
			what = fmt.Sprintf("UINT64 (%d)", a.uint64)
		} else {
			what = fmt.Sprintf("UINT64:%s (%d)", a.name, a.uint64)
		}
	case yy_AND:
		what = "AND"
	case yy_OR:
		what = "OR"
	case yy_FALSE:
		what = "FALSE"
	case yy_TRUE:
		what = "TRUE"
	case COMMAND_SYSATT:
		what = fmt.Sprintf(
				"%s%s%s (ord=%d,rcnt=%d)",
				a.yy_name(), 
				colon,
				a.sysatt_ref,
				a.order,
				a.sysatt_ref.ref_count,
			)
	case PROJECT_OSX_EXIT_CODE:
		what = fmt.Sprintf("PROJECT_OSX_EXIT_CODE: %s", a.sysatt_ref)
	default:
		what = fmt.Sprintf("%s%s%s", a.yy_name(), colon, a.name)
		if a.order > 0 {
			what = what + fmt.Sprintf(" (ord=%d)", a.order)
		}
	}
	return what
}

func (a *ast) walk_print(indent int, parent *ast) {

	if a == nil {
		return
	}
	if parent != nil && a.parent != parent {
		if a.parent == nil {
			a.corrupt("unexpected nil parent")
		}
		a.corrupt("unexpected parent: %s", a.parent.yy_name())
	}
	if indent == 0 {
		fmt.Println("")
	} else {
		if a.parent == nil {
			corrupt("parent ast is nil")
		}
		for i := 0;  i < indent;  i++ {
			fmt.Print("  ")
		}
	}
	fmt.Println(a.String())

	//  print kids

	a.left.walk_print(indent + 1, a)
	a.right.walk_print(indent + 1, a)

	//  print siblings

	if a.prev == nil {
		for as := a.next;  as != nil;  as = as.next {
			as.walk_print(indent, parent)
		}
	}
}

func (a *ast) print() {
	a.walk_print(0, nil)
}

func (a *ast) corrupt(format string, args...interface{}) {

	msg := fmt.Sprintf(format, args...)
	corrupt("%s: node \"%s\", near line %d", msg, a.yy_name(), a.line_no)
	//  NOTREACHED*/
}

//  is the node a binary operator(), left and right must exit
func (a *ast) is_binary() bool {
	switch a.yy_tok {
	case yy_OR, yy_AND, LT, LTE, EQ, NEQ, GTE, GT:
		return true
	}
	return false
}

//  is the node a unary operator(), left only exists
func (a *ast) is_unary() bool {
	switch a.yy_tok {
	case NOT, WHEN:
		return true
	}
	return false
}

func (a *ast) is_flowable() bool {
	switch a.yy_tok {
	case RUN:
		return true
	}
	return false
}

func (a *ast) in_tok_set(expect ...int) bool {

	for _, tok := range expect {
		if tok == a.yy_tok {
			return true
		}
	}
	return false
}

func (a *ast) error(format string, args...interface{}) error {

	var lno string

	if a.line_no > 0 {
		lno = fmt.Sprintf(" @%d", a.line_no)
	}

	return errors.New(
		fmt.Sprintf("node %s%s: %s",
			a.yy_name(),
			lno,
			fmt.Sprintf(format, args...),
	))
}

//  verify type of ast kids are in expected yy type set... and
//  point to proper relatives.

func (a *ast) frisk_kids(twig string, expect ...int) error {
	if a == nil {
		return errors.New(twig + " node is kill")
	}

	e := func(kid *ast, format string, args...interface{}) error {
		fmt := fmt.Sprintf("%s kid (%s)", twig, kid.yy_name())
		return a.error(fmt, args...)
	}

	var k_prev, k *ast
	if twig == "left" {
		k = a.left
	} else {
		k = a.right
	}
	if k == nil {
		return nil
	}
	for ;  k.next != nil;  k = k.next { 
		if k.parent == nil {
			return e(k, "has nil parent")
		}
		if k.parent != a {
			return e(k, "wrong parent (%s)", k.parent.yy_name()) 
		}
		if k_prev != nil && k.prev != k_prev {
			return e(k, "has wrong prev (%s)", k.prev.yy_name())
		}
		found := k.in_tok_set(expect...)
		if !found {
			return e(k, "not in tok set (%s)", yy_names(expect...))
		}
		k_prev = k
	}
	return nil
}

//
//  derive the type of the ast expression.
//
//  Note:
//	why not put the type of an expression in the ast while parsing
//
func (a *ast) yy_type() string {
	switch a.yy_tok {
	case yy_TRUE, yy_FALSE,
	     LT,  LTE,  EQ,  NEQ,  GTE,  GT:
		return "bool"
	case STRING, CONCAT:
		return "string"
	case UINT64:
		return "uint64"
	}
	return "unknown"
}

func (a *ast) is_expression() bool {
	return a.is_bool() || a.is_string() || a.is_uint64()
}

//  Note:  change to multiple tokens ... instead of is_flowable()
func (a *ast) yy_count(tokens ...int) int {
	
	if a == nil {
		return 0
	}
	count := 0
	if a.in_tok_set(tokens...) {
		count++
	}
	count += a.left.yy_count(tokens...)
	count += a.right.yy_count(tokens...)

	if a.prev == nil {
		for kid := a.next;  kid != nil;  kid = kid.next {
			count += kid.yy_count(tokens...)
		}
	}
	return count
}

func (parent *ast) push_left(kid *ast) {

	parent.push_lr(&parent.left, kid)
}

func (parent *ast) push_right(kid *ast) {

	parent.push_lr(&parent.right, kid)
}

func (parent *ast) push_lr(lr **ast, kid *ast) {

	var k *ast

	kid.parent = parent
	if *lr == nil {
		*lr = kid
		kid.order = 1
		parent.count = 1
		return
	}
	for k = *lr;  k.next != nil;  k = k.next {}
	k.next = kid
	kid.order = k.order + 1
	parent.count++
	kid.prev = k
}

func (set *ast) string_element(name string) string { 
	if set.yy_tok != yy_SET {
		set.corrupt("expected SET, got %s", yy_name(set.yy_tok))
	}
	var kid *ast
	for kid = set.left;  kid != nil;  kid = kid.next {
		if kid.name != name {
			continue
		}
		if kid.yy_tok == STRING {
			return kid.string
		}
	}
	return ""
}

//  get a named []string from ARRAY element in a SET

func (set *ast) array_string_element(name string) []string { 

	if set.yy_tok != yy_SET {
		set.corrupt("expected SET, got %s", yy_name(set.yy_tok))
	}
	var kid *ast
	for kid = set.left;  kid != nil;  kid = kid.next {
		if kid.name == name && kid.yy_tok == ARRAY {
			break
		}
	}
	if kid == nil {
		return nil
	}
	ar := make([]string, kid.count)
	var cnt int
	for kid = kid.left;  kid != nil;  kid = kid.next {
		if kid.yy_tok == STRING {
			ar[cnt] = kid.string
			cnt++
		}
	}
	return ar[:cnt]
}

func (a *ast) yy_ancestor(yy_tok int) *ast {

	if a == nil {
		return nil
	}
	if a.yy_tok == yy_tok {
		return a
	}
	if a.parent == nil {
		return nil
	}
	return a.parent.yy_ancestor(yy_tok)
}
